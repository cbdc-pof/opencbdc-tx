Author: Cyrus Minwalla
Organization: Bank of Canada

What was explored:
 - opencbdc-tx public channel version (newer than internal at time of investigation)
 - Branch: trunk
 - Commit ID: 3a33f7e0edf1b1896592f1f4cac688c595df7f7a
 - Date: 2023-Feb-22


Tools used:
 - cppcheck
 - sourcetrail


2023-June-22

- Transactions can only be submitted by clients

- Minting is just another transaction
  - Checks on minting are missing:
     - There are no attestations recorded (as inputs are zero-valued, nothing for sentinels to attest or confirm)
     - Sentinels do not check if the client's key belongs to a list of approved keys
     - Coordinator does not check anything, blindly adds hashes to the hash Sentinels

  - Security for the minting process is insufficient for a feasible design.

  - Could a secure minting solution be added?
    1. For a secure solution, minting has to bypass the Sentinel and be submitted directly to the coordinators
        - Minting operation interface removed from the client API and added to the Coordinator API
    2. Create dedicated minting wallets, with associated keys stored in an HSM and only accessed with sufficient privileges
    3. Coordinators reference a list of key(s) for all minting wallets in existence
    4. Signature verification has to happen inside the HSM
    5. Each wallet requires dual party authorization i.e. two individual signing keys (or KEKs) unlock a single minting key

- Issuance is not a supported transaction
   - There is no mechanism to mint without issuance: A minting operation directly results in a creation of funds within a client wallet
   -
   - Could a secure issuance solution be added?
     1. To support dedicated issuance independent of minting, the solution is similar to minting
     2. Create one or more dedicated issuance wallets (keys)
     3. Coordinators reference a list of key(s) for all issuing wallets in existence
     4. Coordinator verifies both input (minting) and output (issuing) keys
     5. Both signatures are verified inside an HSM
     6. Issuing keys do not require a dual party authorization. Similarly, minting keys used as input do not require dual party authorization


2023-Jun-30
- Explore the client codebase for key management
- More broadly, the system may have a big gap in key management

Gaps
- Key management
- Onboarding
- Full path of the funds model, from creation to destruction
- FI Layer: Sits between the client wallets and the sentinels (Should FIs run sentinels?)
-

(Update: 2024-Jan-29): It was decided later last year that it will be assumed that shards, coordinators and sentinels will be operated entirely by the central bank.

2023-Jul-05

- Provenance: Can only be established through one mechanism, namely checking that the funds are part of the UHS (Unclaimed Hash Set). This sets up a major attack by a rogue employee who could modify the coordinator database and inject funds into the system.
  - Additionally, the payee has no mechanism to verify funds at the time of transaction. Rather the payee must wait until payment is confirmed by the coordinator. Since the payer and payee transfer tokens through an asynchronous, out-of-band channel, the payee must either confirm settlement with the coordinator, or assumed it's settled until the payee can reach out to the coordinator. This is risky in general, as there should be a local mechanism to confirm funds. Furthermore, this precludes inclusion of any sort of offline functionality in the future.
  - In a nutshell, only one control exists for provenance: Consult with the coordinator (or watchtower). This violates the security principle of defense in depth.

Could the issue of provenance be fixed? It can through one or more technologies.
 - Consulting a recorded transaction history at an authoritative source is one mechanism.
 - Adding digital signatures to tokens is another.

- Access control:
  - It's not clear what sort of roles and access rights are currently implemented in the system. Is the system completely relying on ACL functionality from the cloud service provider? If so, that is likely insufficient from a CBDC perspective.

- Key management system:
  - The client wallet requires a robust key management system for enrollment, private and secure transaction creation and key lifecycle.
_____________________________________________________________________________________________________________________________________________________________________________________________________________

BIG GAP: Notes in notebook and PoF doc
_____________________________________________________________________________________________________________________________________________________________________________________________________________

2024-Jan-19
- Channel security is disabled throughout the system
  - Even with the perimeter security assumption, the wallet is communicating over the public internet with the sentinel and needs to build a secure channel before submitting a signed transaction
  - Introducing channel security will have a performance impact, and on that matter, Sam admitted that the reason for leaving it out was performance
  - The credentials used for building the secure channel will be assigned as part of enrollment (registered or non-registered)
    - User credentials can be based on Verifiable Credentials or their private sub-set Anonymous Credentials
  - Secure channels are not required between sentinels and coordinators or coordinators and shards as long as they reside within the same cloud zone (and ideally within the same tenant).
    - We have to introduce channel security between any components that violate this assumption. This includes sentinel<->sentinel, coordinator<->coordinator and shard<->shard traffic.

2024-Jan-29
- On a call with Sam Stuewe from MIT last week (Jan 26), it was made clear that the wallet is simply a reference implementation. Explicit design choices such as Schnorr signatures, 10,000 randomly generated keys and arbitrary selection do not underlie a specific rationale, rather they were chosen simply for convenience and speed/performance. OpenCBDC leaves the wallet design entirely up to the application developer/integrator.
- Additionally Sam considered the concept of a cryptographic receipt, generated by the coordinator, at the time of settlement. Such a receipt could be verified by the wallet to affirm that a transaction has been settled as submitted, and could additionally be archived at both the wallet and the sentinel for later verification. In particular, the sentinel could keep a record of such transactions along with transaction ID as a non-repudiation mechanism.
- Fault detection with the Pedersen commitment solution is still an open problem. In case of a discrepancy in the bulletproof++ solution, it should be possible to identify the precise transaction where the discrepancy occurred. Furthermore, the system should record sufficient forensic information to pinpoint the precise wallet where the transaction occurs. Additionally, information revealing the wallet will need to be kept private and only revealed under duress.
Transactions in openCBDC are signed by a Schnorr signature:
  - Primitive construction: Schnorr signatures are an elliptic curve primitive. Secp256k1 is a popular curve for construction. Signature unforgeability is derived from the hardness of the discrete logarithm problem, in line with other elliptic curve cryptographic primitives.
  - One-time signatures: It is trivial to generate one-time signatures with the Schnorr scheme. Note that each signature must use a unique nonce, as it is trivial to reveal the private key if a nonce is ever reused. In OpenCBDC, the wallet generates multiple unique keypairs at the time of creation, and chooses one at random to sign the transaction. The underlying cryptographic library is sourced from Bitcoin-core.
  - Aggregated (multi-sig) transactions are easy to construct: In ECDSA, a multi-sig payload requires each public key to be concatenated to the payload for verification. With Schnorr signatures, multiple public keys can be mathematically combined into one public key, which can be used to verify all of the signatures attached to the payload. Shrinking multiple public keys into one saves space on the payload, resulting in more efficient transactions.

******** Internal design thinking ********
A wallet system for payments must consider the design of the following areas to achieve desired goals:
- Device provisioning
- Transaction signature
- Key storage/update/revocation mechanisms

In cases where a trusted authority is mentioned, it describes the central bank or an agent of the central bank operating on its behalf.

Desired goals for a CBDC signature scheme
 - Controlled Enrollment/Revocation: Only wallets onboarded by a trusted authority are allowed to participate in the CBDC system. The trusted authority derives its authority from the central bank. Similarly, if a trusted authority revokes a key, then that wallet should become unusable throughout the system.
 - One time signature: The public key primitive used by the spending key issued to enrolled/onboarded wallets can generate one-time use keys to prevent linkability between transactions
 - (For Bulletproof++) Pedersen commitment: The public-key primitive must support the creation of a commitment and one or more range proofs. OpenCBDC assumes a Pedersen commitment, but we can consider others based on security and performance goals.

These desired properties must be satisfied through design choices made for each area.

Device Provisioning: Can take two forms
  a) Spending key is generated at the trusted authority and transferred to the device as part of the onboarding process. Once onboarding is complete, the trusted authority deletes it's copy of the generated keypair
  b) Device creates a local spending keypair, the public version of which is signed by the trusted authority during onboarding.

  Option a) is more secure for mobile and desktop devices since the platforms are untrusted, namely that the CB only has access to the application layer and lacks insight into the underlying environment/OS/firmware/hardware layers.
  Option b) reduces the barrier to entry by allowing anyone with a public-private keypair to enroll into the system.

  Ergo, Options (a) and (b) create a trade-off between user choice and system security.

Transaction Signatures:
  a) Long-lived key: Transactions are signed by a long-term use key, allowing them to be linked.
  b) Ephemeral (one-time use) key: A key is generated on the fly for a specific transaction, generated from the long-lived key (master secret).
      - Ephemeral keys may be generated randomly or deterministically.
      - Randomly generated ephemeral keys are indistinguishable from the master secret and unlinkable to a unique wallet. Schnorr signatures support this by default, nothing extra is needed to put them into practice.
      - Deterministic generation may rely on transaction information acting as input or a cryptographic ratchet. In Schnorr signatures, we would need to inject randomness in addition to deterministic information to ensure uniqueness.
      - Ratchet-generated ephemeral keys are unlinkable by observers, but can be reconstructed with knowledge of the master secret.
        - Note: It is possible to link two distinct master keypairs through a double-ratchet mechanism.
  c) Privacy:
      - Long-lived keys can achieve pseudo-anonymity at best. Working with the MSB, the trusted authority can link a specific wallet to a specific user, an explicit transaction record is not required to make that link.
      - Randomly generated keys are akin to one-time signatures and guarantee k-anonymity where k is the set of all users (the best privacy possible in an enrolled system). Wallets are unlinkable between transactions and
        there is no way to trace a specific address (public key) back to a specific
        wallet. In the event of a fraudulent transaction, it becomes impossible for the trusted authority to trace a transaction back to a specific wallet, and by extension, a specific user. Involving MSBs makes the problem more tractable. If we assume that registered users have no privacy wrt their MSBs, and additionally require MSBs to keep track of transactions, then an MSB can use its data to link a specific transaction to a specific user on behalf of the trusted authority.
      - Ratchet generated keys can allow reconstruction of a specific address, provided the master key used to generate that address is known. Once again, involving MSBs is the primary mechanism, where if an MSB keeps a
        record of the transaction, and the specific user, the long-lived key (master secret) can be used to reconstruct the address. This is a stronger guarantee than randomly generated keys as there would be a mathematical proof linking a long-lived key to a specific address. Additionally, the trusted authority could keep a copy of all keys and conduct an exhaustive search. It's not clear whether this is computationally feasible in a defined timeframe (requires investigation). In general, this approach may be undesired as the trusted authority would need to keep a copy of all wallet keys, weakening all privacy claims.
      - A double ratchet mechanism may make it possible for the central bank to derive a ratchet-generated key without having access to the wallet's long-lived key. In this case, for every long-lived key, the central bank would possess a linked key created during provisioning. It is unclear what the implications of this approach would be. This is TBD, requires further research.
      -

Key storage/update/revocation:
 - Storage: Keys can be stored in secure hardware dedicated to key storage. On mobile devices, keys can be loaded to or generated in the secure element, which of the two is possible depends on platform support.
    - In the K and M wallet configurations, the burden of storing keys falls on the MSB. These MSBs could rely on enterprise-grade HSM appliances or equivalent to store the keys. Each wallet is pre-seeded with 10,000
      unique keys, resulting in a very large number of keys for a particular MSB to manage. While an MSB could purchase additional HSMs to meet the demand, the private key slots on enterprise-grade HSMs are limited and such an approach would be cost-prohibitive. The common approach in industry to resolve this problem is to use a Key Encryption Key (KEK), whereby wallet keys are stored encrypted on regular (non-secure) storage, while keys used to encrypt the wallet keys are stored in the HSMs. In this model, one secure key encrypts a batch of wallet keys, allowing a small number of HSMs to protect a large number of keys. This protects keys at rest and in transit, but not keys in processing. To achieve protection for keys in processing, the wallet key must be decrypted in the HSM, then used to sign a transaction and then deleted from the HSM (keys do not need to be re-encrypted since they are unchanging). The resultant transaction is then exported and submitted to the back-end.

 - Update: Long-lived keys in wallets may require to be periodically refreshed. Since the UHS/UTXO model does not rely on specific wallet behaviour, keys could be changed in between two subsequent transactions without impacting the back-end.
   - Switching to another cryptographic scheme, for instance a quantum-safe primitive, will impact the signature sizes. In the case of a quantum-safe primitive, the increase will be significant, impacting system performance. At this stage, we do not consider the introduction of a quantum-safe primitive as many aspects of the transaction model will be affected, but the path to quantum-safety will need to be considered at some point.

 - Revocation: K and M wallets can be revoked trivially by the associated MSB (in K, the funds would simply be frozen). U keys will prove to be more challenging, requires more thinking. It is straightforward to blacklist compromised or fraudulent U wallets such that no M wallets can interact with them. K wallets can be blocked from sending but not receiving, requires more thinking.
**********************************************
